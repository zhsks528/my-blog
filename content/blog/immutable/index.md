---
title: "불변성의 중요성"
date: "2020-09-05T13:59:33.216Z"
category: "fe"
emoji: "🔥"
---

## 불변성의 중요성

### 1. 순수함수와 불변성의 관계

순수함수는 수학의 함수를 프로그래밍의 세계로 가져온 모델이다.

프로그래밍의 세계에는 무언가를 저장하고 변경하고 불러올 수 있는 상태라는 개념이 존재하지만, 수학의 세계에는 그런 개념이 없기 때문에 모든 함수는 함수 외부의 무언가에 절대 영향을 받지 않고 독립적으로 존재한다.

그렇기 때문에 상태라는 개념 자체가 존재하지 않는 수학의 함수를 프로그래밍으로 구현한 모델인 순수 함수 또한 함수 외부의 상태에 영향을 받지 않아야한다는 규칙을 가질 수 밖에 없다.

또한 수학의 세계에는 상태라는 개념이 없기에 당연히 상태를 변경한다는 개념도 없을 수 밖에 없고, 우리는 이를 `불변성(Immutable)`이라고 부른다.

하지만 프로그래밍의 세계에서 상태를 변경하지 않는다는 것은 꽤나 신경을 많이 써줘야 하는 일이다. 그래서 우리는 **"변수에 값을 재할당하지 않는다"**와 같은 몇 가지 규칙들을 정해놓고 프로그래밍을 하면서 불변성을 유지한다.

하지만 프로그램에서 변이(Mutation)가 발생하는 근본적인 원인을 파악하고 불변성을 스스로 지켜나간다면, 이러한 규칙들이 커버할 수 없는 변태같은 상황을 마주치더라도 대응할 수 있기 때문에 우리는 `불변(Immutable)`이 정확히 무엇을 의미하는 지 알아야 할 필요가 있다.

### 2. 불변성의 정의

보통 불변성의 의미는 `상태를 변경하지 않는 것`이라는 간단한 정의로 설명된다.

그러나 대부분 불변성에 대한 설명을 할 때, “함수 외부의 변수에 접근, 재할당해서는 안된다”, “함수의 인자를 변경하면 안 된다”와 같이 상태를 변경하는 행위를 금지하는 예시 정도만 설명하고, 상태를 변경한다는 것이 정확히 무엇을 의미하는지는 자세히 설명하지 않는다.

그래서 이런 설명 방식은 상태를 변경한다는 것이 정확히 어떤 의미인지 모르는 사람에게는 잘 와닿지 않을 수 있다고 생각한다.

그렇다면 불변성이 이야기하고 있는 `상태의 변경`이라는 것이 정확히 어떤 행위를 의미하는 것일까? 단순히 프로그램의 변수를 변경하거나 재할당 하지 않는 것을 이야기하는 것일까?

사실 불변성이 이야기하는 상태의 변경이라는 것은 단순한 변수의 재할당을 이야기하는 것이 아니다. 정확히 말하면 메모리에 저장된 값을 변경하는 모든 행위를 의미하며, 여기에 변수의 재할당과 같은 행위도 포함되는 것이다.

즉, 상태의 변경이라는 행위를 제대로 이해하기 위해서는 컴퓨터가 값을 어떤 방식으로 메모리에 저장하고 접근하는지에 대한 간단한 지식이 필요하다.

### 3. 불변성을 지킬시의 장점

프로그래밍을 하면서 상태의 불변성을 지키려면 자연스럽게 이것저것 신경써줘야하는 것들이 늘어날 수 밖에 없다. 그럼에도 불구하고 불변이라는 개념은 현재 많은 개발자들에게 환영받고 있는 개념이라는 것이 사실이다.

도대체 상태가 변경되지 않게 함으로써 얻을 수 있는 것이 무엇이길래, 다들 이렇게 불변불변하는 것일까?

#### 3-1. 무분별한 상태의 변경을 막는다

상태는 프로그램의 현재 상황을 보여주는 좋은 역할도 하지만, 여기저기서 무분별하게 이 상태를 참조하거나 변경하는 경우, 개발자조차 현재 프로그램이 어떻게 돌아가는지 파악하기 힘든 슬픈 상황이 발생할 수도 있다.

그래서 개발자들은 상태를 변경하는 행위에 특정한 규칙과 제약을 정해서 무분별한 상태 변화를 최대한 피하고, 이런 변화를 추적할 수 있는 상황을 선호할 수 밖에 없다.

**무분별한 상태 변경 때문에 프로그램이 터지게 되는 가장 대표적인 상황은 바로 “전역 변수의 남용”이다.** 자바스크립트에서 전역 변수의 사용을 아예 금지하는 컨벤션을 추천하는 것도 바로 이 이유이다.

```js
let greeting = 'Hi';

function setName () {
  name = 'Evan';
}

setTimeout(() => {
  greeting = 'Hello';
}, 0);

setName();
console.log(`${greeting}, ${name}`);
```

`greeting` 변수는 전역 스코프에서 선언된 전역 변수이고, `setName` 함수 내부에서도 암묵적으로 전역 변수를 선언하고 있으며, `setTimeout`의 콜백 함수 내에서도 전역 변수인 `greeting`의 값을 재할당하고 있다.

이런 상황에서는 어디서 어떤 놈이 `greeting`이라는 전역 변수의 상태를 변경했는지 추적이 거의 불가능하며, 갑자기 콘솔에 `Hi, Evan`이 아닌 `Get out, Evan`이라고 출력된다고 해도 전혀 이상할 것이 없다.

개발자가 이런 상황을 만났을 때 야근을 하는 이유는, 슬프게도 이게 버그가 아니기 때문이다. 이 코드들은 콘솔에는 어떠한 에러도 출력되지 않는 지극히 정상적인 로직이다. (차라리 에러라도 나는 것이 디버깅은 더 쉽다)

불변성을 유지하며 순수 함수를 사용한다는 것은 함수 외부의 상태에 접근하여 이미 메모리에 할당되어 있는 값을 변경하지 않는다는 의미이므로, 이렇게 예측하지 못한 상태의 변경을 방어할 수 있다.

#### 3-2. 상태의 변경을 추적하기가 쉽다

**일반적으로 자바스크립트의 객체의 프로퍼티나 배열의 원소를 변경해야하는 경우, 필연적으로 불변성이 깨질 수 밖에 없다.**

애초에 배열이나 객체가 처음 나왔을 때, 어딘가에 구조화된 데이터를 저장해놓고 상태를 유지하고 변경해가며 사용하고자 하는 목적을 가지고 있었기 때문이다.

```js
const evan = { name: 'Evan' };
evan.name = 'Not Evan'; // 상태 변화!
```

하지만 이렇게 기존에 메모리에 저장되어있는 값을 변경하는 행위는 불변의 법칙을 정면으로 위반하는 것이기 때문에, 불변성을 유지하고 싶은 개발자는 이런 식으로 객체의 프로퍼티나 배열의 원소를 변경할 수 없다.

게다가 방금 보았던 무분별한 전역 변수의 사용과 마찬가지로 객체나 배열의 상태 변화 또한 추적할 수 없는 문제이기 때문에, 어디서 이상한 놈이 엄한 객체나 배열의 상태를 변경하여 버그가 발생하더라도 개발자가 이를 디버깅하기란 쉽지 않은 문제이다.

그렇다고 객체의 프로퍼티나 배열의 원소를 변경하지 못하도록 할 수도 없는 노릇이다. 그럼 어떻게 이 문제를 해결해야할까?

한번 객체의 프로퍼티를 변경하는 간단한 함수를 통해 객체의 프로퍼티를 변경할 때 발생하는 상태 변화의 재현과 해결 방법을 알아보도록 하자.

```js
function convertToJohn(person, name) {
  person.name = 'John';
  return person;
}
```

`convertToJohn` 함수는 객체를 인자로 받아, 해당 객체의 `name` 프로퍼티에 `John`이라는 문자열을 할당하는 역할을 하는 함수이다. 즉, 이 함수는 객체의 상태를 변경하는 역할을 하고 있다.

일단 결론부터 이야기하자면 이 함수는 순수 함수가 아닌데, 그 이유는 함수가 참조에 의한 호출 방식을 사용하는 객체의 프로퍼티를 직접 변경하면 함수 외부에 있는 원본 객체의 상태도 변경되기 때문이다.

```js
const evan = { name: 'Evan' };
const john = convertToJohn(evan);

console.log(evan);
console.log(john);
{ name: 'John' } // ?
{ name: 'John' }
```

`convertToJohn` 함수를 사용하는 사람은 함수의 이름만 보고 “오호, 이 함수는 어떤 객체를 존 객체로 바꿔주는 함수로군?”이라고 생각하겠지만, 이 함수는 개발자 몰래 자신의 인자로 받은 객체까지 변경해버리는 나쁜 함수였다.

이렇게 의도하지않은 객체의 프로퍼티가 변경되는 것도 문제지만, 사실 더 큰 문제는 이런 상태의 변화를 전혀 추적할 수 없다는 것이다. 당장 위 예시의 `evan` 객체와 `john` 객체를 비교해보면 자바스크립트는 두 객체가 같은 객체라고 평가해버린다.

두 객체는 메모리 공간에 접근할 수 있는 변수명만 다를 뿐, 실제로는 같은 메모리 공간에 저장되어 있는 같은 객체이기 때문이다.

```js
console.log(evan === john);
true
```

이런 상황에서 개발자는 “의도하지 않은 객체의 상태 변화”와 “상태의 변화를 추적할 수 없다”는 고약한 문제를 떠안게 된다. 그렇다면 이 문제를 어떻게 해결할 수 있을까?

이 문제는 생각보다 간단하게 해결할 수 있는데, `name`을 `John`으로 가지는 객체를 그냥 새로 생성해버리면 된다.

```js
function convertToJohn (person) {
  const newPerson = Object.assign({}, person);
  newPerson.name = 'John';

  return newPerson;
}

const evan = { name: 'Evan' };
const john = convertToJohn(evan);

console.log(evan);
console.log(john);
{ name: 'Evan' }
{ name: 'John' }
```

변경된 `convertToJohn` 함수는 더 이상 인자로 받은 `person` 객체에 직접 접근해서 값을 수정하지 않는다. **다만 `Object.assgin` 메소드를 사용하여 `person` 객체와 동일한 구조를 가진 새로운 객체를 생성하고 `name` 프로퍼티를 `John`으로 변경한 후 반환할 뿐이다.**

**이런 과정이 너무 불편하게 느껴진다면 ES6의 `spread` 연산자를 사용하면 더 간단한 문법으로 변경할 수도 있다.**

```js
function convertToJohn (person) {
  return {
    ...person,
    name: 'John',
  };
}
```

이렇게 새로운 객체를 생성하게 되면 의도하지 않은 객체의 상태 변화도 방어할 수 있고 상태 변화를 추적할 수도 있게 된다. 왜냐하면 `convertToJohn` 함수가 뱉어낸 객체는 `evan` 객체와는 전혀 다른, 새로운 객체이기 때문이다.

```js
console.log(evan === john);
false
```

객체의 상태를 변화시킬때, “상태가 변화된 객체”를 새로 생성한다면 우리는 이전 상태를 가진 객체와 다음 상태를 가진 객체를 비교하며 `false`가 나온다는 사실을 이용하며 객체의 상태가 변화되었음을 알 수 있는 것이다.

이런 원리는 웹 프론트엔드의 UI 라이브러리인 `리액트(React)`에서 상태의 변화를 감지하는 데에도 사용되고 있는데, 리액트는 개발자가 `setState`와 같은 메소드를 사용하여 상태를 변경했을 때 `Object.is` 메소드를 사용하여 이전 상태와 다음 상태를 비교하고 두 객체가 같지 않다고 평가되면 상태가 변이되었다고 판단하고 컴포넌트를 다시 렌더한다.

또한 상태 관리 라이브러리인 `리덕스(Redux)` 또한 동일한 원리로 상태의 변화를 판단하기 때문에, **리듀서를 작성할 때는 기존 `state` 객체의 프로퍼티를 직접 변경하지 않고 새로운 객체를 생성해서 반환해야한다.**

```js
function reducer (state, action) {
  switch (action.type) {
    case SET_NAME:
      return {
        ...state,
        name: action.payload,
      };
    // ...
  }
}
```

이러한 불변성의 특징들은 참조에 의한 호출을 사용하는 자료형들의 상태 변화를 쉽게 감지할 수 있도록 만들어주기 때문에 개발자가 예상하지 못하는 방향으로 버그가 발생하는 것을 어느 정도 막을 수 있다.

#### 3-3. 멀티 쓰레딩을 사용할 때 매우 유용

불변성은 멀티 쓰레딩을 사용할 때도 매우 유용한데, 여러 개의 쓰레드가 한 개의 상태를 정신없이 수정하고 참조하게되면 어느 순간부터는 도대체 쓰레드가 참조한 게 어떤 값인지 파악하기가 힘들기 때문이다.

이건 마치 하나의 종이에 여러 명의 화가가 물감을 칠하면서 그림을 완성해가는 느낌이라고 할 수도 있을 것 같다. 그러나 불변성이 제대로 지켜진다면 각자 쓰레드마다 종이를 주고 그림을 그려서 제출하라는 상황과 비슷하다.

개발자는 각 쓰레드가 그림을 제출할 때마다 상태가 변경되었음을 감지할 수도 있고, 이를 이용하여 그림의 상태가 변경되는 로그를 쌓을 수도 있다. 이후 그 그림들을 어떻게 취합하던, 필요없는 그림은 버리던 그건 그 후의 문제로 분리하면 되는 것이다.



### 참조

- https://evan-moon.github.io/2020/01/05/what-is-immutable/